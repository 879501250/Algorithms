# 行为型模式

## Chain Of Responsibility

### 概述

**责任链模式是**解决一组服务中的先后执行处理关系，将请求的处理者串联成一个链条或树形结构，请求沿着责任链传递，直到有一个对象处理了它为止。

> 当普通责任链中某个处理者能够处理当前请求时立即返回，而升级后的功能链，将遍历链上的所有处理者，都进行处理。

例如：filter 和拦截器的处理方式、流水线的加工

### 对比

#### 状态模式

- **状态模式：**需要让每个状态知道下一个需要处理的状态是谁
- **责任链模式**：不确定下一个处理者是谁，安装编排顺序处理

### 应用场景

- 当一个请求可能要被很多对象一起处理时
- 不确定接受者是谁

### 优点

- 将请求的发送者和接收者解耦，发送者无需关心请求的处理过程，只需将请求交给责任链的起点就行。
- 责任链可以动态组合，并配置责任链上处理者的处理顺序，可随时增加拆除责任链中的某个请求对象

### 缺点

- 如果责任链太长或责任链中请求的处理时间过长，可能会影响性能

## Command

### 概述

**命令模式**将不同的请求封装成不同的请求对象，以便使用不同的请求；对于接收者来说，可以识别不同的请求对象类型，然后执行不同的操作。

### 对比



### 应用场景



### 优点

- 使命令发送者和执行者解耦

### 缺点

- 针对每个命令都要开发一个与之对应的命令，增加复杂度

## Iterator

### 概述

**迭代器模式**提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。

### 对比

#### 访问者模式

两个模式都是迭代地访问集合对象中的元素

- **访问者模式：**扩展开放的部分，作用于对象的操作上
- **迭代器模式：**扩展开放的部分，是在对象的种类上

### 应用场景

- **内容保密：**访问集合对象的内容，无需暴露内部表示 ;
- **统一接口：**为遍历不同的集合结构，提供统一接口 ;

### 优点

- 分离了集合对象的遍历行为，保证内部数据表示不暴露给外部以防搞乱内部机制
- 抽象出了迭代器负责集合对象的遍历，提供给用户遍历并访问到每个数据的权限，可以让外部的代码透明的访问集合内部的数据

### 缺点

- 将存储数据和遍历数据两个职责拆分，因此没新添加一个 集合类，都需要增加该集合类对应的迭代器类，类的个数成对增加

## Mediator

### 概述

**中介者模式**定义一个封装一组对象如何交互的对象（将一对多转化为一对一），中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

### 对比

#### 观察者模式

两者经常结合起来使用，使用**观察者模式**实现**中介者模式**中，角色间的通信

### 应用场景

- **引用关系复杂：**系统中对象之间存在复杂的引用关系，产生相互依赖关系，从而结构混乱，难以理解
- **改变行为：**交互的公共行为，如果需要改变行为，可以增加新的中介者类（通过增加新的中介者类， 达到扩展的目的）

### 优点

- 将一对多转化为一对一，降低了程序复杂程度
- 实现了类之间的解耦操作

### 缺点

- 如果在业务场景中中介者数量过多， 会导致系统复杂性增加


## Memento

### 概述

**备忘录模式**实现在不破坏原有属性类的基础上保存对象的某个状态，以便在适当的时候恢复对象。

### 对比

#### 状态模式

- **备忘录模式状态表示：**使用对象实例表示状态，当前对象的存档是该对象的实例
- **状态模式状态表示：**使用类表示状态

### 应用场景

- 保存、恢复数据的相关业务场景，从而可以在“后悔”的时候，将对象恢复到之前的状态

### 优点

- 为用户提供一种可恢复机制
- 实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。
- 简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合**单一职责原则**。

### 缺点

- 会额外占用磁盘、内存等资源

## Observer

### 概述

**观察者模式**定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

> JDK 中提供了观察者模式的支持
>
> - 被观察者：被观察者继承 Observable 类
>
> - 观察者：观察者实现 Observer 接口
> - 关联观察者与被观察者：调用被观察者的 addObserver 方法，关联二者
> - 触发通知：被观察者数据改变时，调用 setChanged 和 notifyObservers 方法，会自动回调观察者的 update 方法

### 对比



### 应用场景

在购物网站，多个用户关注某商品后，当商品降价时，就会自动通知关注该商品的用户

### 优点

- 在观察者和被观察者之间，建立了一个抽象的耦合，由于耦合是抽象的，可以很容易扩展观察者和被观察者
- 建立一套触发机制，类似于消息广播，如果需要接收消息，只需要注册一下即可

### 缺点

- 如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。
- 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。
- 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。

## State

### 概述

**状态模式**描述的是一个对象在内部状态改变时，其行为也相应发生变化。将状态判断逻辑，转到代表不同状态的一系列类中

### 对比

#### 享元模式

经常配合在一起使用，使用享元模式，在多个上下文中，共享状态实例

### 应用场景

- 一个对象，存在多个状态，状态可以相互转换，不同状态下，行为不同

  如：购买物品，将物品放入购物车并生成订单，可以进行付款；如果订单超过24小时后，被关闭订单，此时订单取消，无法付款

- 一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。这个状态通常用一个或多个枚举常量表示。通常, 有多个操作包含这一相同的条件结构。State模式将每一个条件分支放入一个独立的类中。这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化

### 优点

- 将不同的状态隔离，每个状态都是一个单独的类
- 将各种状态的转换逻辑，分布到状态的子类中，减少相互依赖

### 缺点

- 状态数量比较多，状态类的数量会增加，业务场景系统变得很复杂 

## Strategy

### 概述

**策略模式**定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。

### 对比

#### 工厂模式

- **工厂模式：**接受指令，创建出符合要求的具体对象，是创建型设计模式。
- **策略模式：**接受创建好的实例对象，从而实现不同的行为，是行为型设计模式。

#### 状态模式

- **策略模式：**使用策略模式时，客户端需要知道使用哪个策略；如果系统中某个类的某个行为有多种实现方式，使用策略模式 
- **状态模式：**使用状态模式时 , 客户端 不需要知道具体的状态，这些状态之间会自动转换；如果系统中某个对象存在多种状态，在不同状态下行为有差异的话，使用状态模式

### 应用场景

- 系统需要动态地在几种算法中选择一种
- 一个系统有许多许多类，而区分它们的只是他们直接的行为
- 在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护

### 优点

- 算法可以自由切换
- 避免使用多重条件判断
- 可以在不修改原有系统的基础上，选择不同的行为，也可以额外扩展其它行为
- 提高算法的保密性和安全性，在终端使用策略时，只需要知道策略的作用即可，不需要知道策略是如何实现的

### 缺点

- 策略类会增多
- 所有策略类都需要对外暴露，客户端必须知道所有的策略类，并且自行决定使用哪个策略类

## Template Method

### 概述

**模板方法模式**定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。子类不可以改变算法的结构只能改变该算法的某些特定步骤的实现细节。

> 西游记每一集的模板就是妖怪出现抓住唐僧，悟空去找神仙帮忙，最终救出唐僧。

### 对比

#### 工厂方法模式

工厂方法是模板方法的一种特殊实现

#### 策略模式

都封装了算法逻辑

- **策略模式**的目的是使各种算法之间可以相互替换，并且不影响最终用户的使用，对终端用户透明，可以改变算法流程的
- **模板方法模式**针对一个算法流程，将其中某些不太一样的算法步骤交给子类实现，不会改变算法流程

### 应用场景

一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。

各个子类中，公共部分被提取出来集中到一个公共的父类中，避免代码重复

### 优点

- 将相同部分代码放在抽象的父类中，提高代码的复用性
- 将不同的代码放在不同的子类中，通过对子类的扩展增加新的行为，符合**开闭原则**

### 缺点

- 每个不同的实现都需要定义一个子类，会导致类的个数增加
- **模板方法**主要通过继承实现，继承关系自身就有缺点，如果父类增加新的抽象方法，所有的子类都要修改一遍

## Visitor

### 概述

**访问者模式**将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离。

> 业务开发中通常将实体数据封装为不同的 POJO 类，内部除了 getter 和 setter 方法外不包含任何业务逻辑，而是将对业务放在 Service 类里进行处理，让 Service 作为拜访者去访问实体类封装的数据。这与访问者模式有着一定异曲同工之处，都是将数据结构和数据操作分离。

### 对比

#### 迭代器模式

都是在某 数据结构（List、Set、Map）上进行处理

- **访问者模式：**主要用于对保存在数据结构中元素，进行某种特定处理，重点是**处理**
- **迭代器模式：**主要作用就是遍历数据结构中的元素，重点是**遍历**

### 应用场景

有多个实体类，其内部都包含者自己的特有的业务逻辑，这些实体类的业务相同，只是具体实现不同，因此额外声明一个类（访问者）表示这个公共的业务，内部针对这个业务**重载**了多个方法，根据实体类的不同，调用不同的方法（即原本定义在实体类内部的业务方法），从而实现将数据结构和数据操作分离。除此之外在实体类内部可提供一个接待接口，由这个接待接口通知访问者来访问本类，可以解决当多种不同的实体类要存储 List、Set、Map 等数据结构中而只能使用泛型，导致访问者无法判断实体类的类型而无法确定该调用哪个业务方法的问题；还可以通过新增额外的访问者，在不修改原有逻辑的情况下，增加对实体类新的操作。

> 日常使用频率很低

### 优点

- 在不修改对象结构中的元素的情况下，为元素增加新功能容易，只要新增访问者即可
- 每个访问者都代表一类相同的业务，功能单一，符合**单一职责原则**

### 缺点

- 增加数据结构，需要在访问者中都增加相应业务方法，违背了**开闭原则**
- 要修改实体的业务需要修改所有访问者中的业务
- 访问者了解实体类中的所有细节，这破坏了对象的封装性。
- 违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类。

## Interpreter

### 概述

**解释器模式**对某种语言定义它的文法（语法）的一种表示，并定义一个解释器，这个解释器用来解释语言中的句子。

> Java 代码编写后需要编译才能让系统“读懂”然后运行，这里的编译器就相当于解释器。

### 对比

#### 适配器模式

- **适配器模式：**不需要预先知道适配器的规则
- **解释器模式：**需要预先将规则写好，根据规则执行解释

### 应用场景

如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题

> 日常使用频率很低

### 优点

- 语法由很多类表示，容易改变及扩展”语言“


### 缺点

- 每个规则都要与之对应一个类，如果规则太多，则需要创建很多类
