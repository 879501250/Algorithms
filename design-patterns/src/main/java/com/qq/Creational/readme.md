# 创建型模式

在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。

## Factory Method

### 简单工厂

#### 概述

相同的产品有一个共同的接口，由一个工厂类同一的创建这个接口下所有的实现类。

> 当将工厂类创建产品的方法为静态方法时，即为静态工厂方法。

#### 使用场景

- 当需要创建的对象少。
- 客户端不需要关注对象的创建过程时使用，需要一个同一创建对象的接口。

#### 优点

- 由工厂来处理创建对象的细节，使产品的创建和使用（业务逻辑）分离，降低耦合。如果要实现新产品直接修改工厂类，而不需要在业务层（controller）中修改，更加容易扩展。
- 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数，传入工厂即可直接获取对应产品。

#### 缺点

- 增加新产品时还是需要修改工厂类的代码（增加 ifelse 判断），违背了**开闭原则**。

  > 可以通过引入配置文件，将工厂能够生产的所有产品全类名写在配置文件中，工厂只需加载配置文件从而创建指定产品即可在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。

- 一个工厂要创建所有产品，职责过重，一旦不能正常工作，整个系统都要受到影响，违反**单一职责原则**。

### 工厂模式

#### 概述

**工厂模式**又称工厂方法模式，其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。

**简单工厂**是通过一个工厂类负责所有对象的创建，而**工厂方法模式**是每个对象都对应有一个工厂类来进行创建。工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，即通过不同的工厂子类来创建不同的产品对象。

#### 使用场景

- 客户端不需要关注对象的创建过程时使用，只要知道哪个工厂能创建需要的产品就行。
- 工厂类只需提供一个创建对象的接口，具体创建哪个对象，以及如何创建的任务委托给具体工厂。

#### 优点

- 用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；
- 在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足**开闭原则**；

#### 缺点

- 每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，当产品多时，工厂类数量会很多。

## Abstract Factory

### 概述

**抽象工厂模式**，相较于**工厂方法模式**一个工厂只能生产一个对象，**抽象工厂模式**将同一类型的多种产品封装到一个工厂内，一个工厂能够创建多种产品，从而避免创建太多工厂；相较于**简单工厂**，**抽象工厂模式**将工厂的代码抽象出来，通过继承的方式让子类去做决定创建哪种同一类型的不同产品。

| 工厂     | 产品种类 | 产品类型 |
| -------- | -------- | -------- |
| 简单工厂 | 多种     | 多种     |
| 工厂方法 | 一种     | 一种     |
| 抽象工厂 | 多种     | 一种     |

例如：

- 家电有很多种类（电视机、冰箱、空调等），品牌也有很多（美的、格力等）：简单工厂中通过一个工厂就能创建所有品牌所有种类的家电；工厂方法中一个工厂只能创建一个品牌下的一种家电；抽象工厂中一个工厂能够创建某一品牌下的所有不同种类的家电。
- 操作系统有很多种（Windows、Linux、Mac等），操作系统中的指令集不同：抽象工厂的具体实现类对应不同操作系统，因此一个工厂能够获取对应操作系统的统一指令集。

### 使用场景

- 系统中有多于一个的产品族，但每次只使用其中某一产品族
- 属于同一个产品族的产品将在一起使用

- 系统稳定，不会额外增加对象。

### 优点

- 当一个产品族中的多个对象被集成到一个工厂里，它能够保证客户端调用同一个工厂始终只使用同一个产品族中的对象
- 增加新的产品族很方便，无须修改已有系统，符合**开闭原则**

### 缺点

- 增加新的产品种类麻烦，不仅需要在抽象工厂中增加方法，对已有的所有具体工厂都有就行修改，违背了**开闭原则**

## Builder

### 概述

**建造者模式**就是通过将多个简单对象通过一步步的组装构建出一个复杂对象的过程。

这样的根据相同的`物料`，不同的组装所产生出的具体的内容，就是建造者模式的最终意图，也就是**将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示**

例如：电脑有不同的配件（cpu、显卡、鼠标、键盘、显示器、内存），不同的配件也有各自的型号，如 cpu 分为 i3、i5、i7、i9 等，这些配件可以相互随机组成一台电脑。

### 使用场景

- 一个复杂对象由多个不同的简单组件组成，每个简单组件都有不同的实现类，不同组件之间可以随机组合成最终的对象

### 优点

- 将一个复杂对象分解为各个组件
- 可以控制整个对象的生成过程和顺序

### 缺点

- 对不同类型的对象需要实现不同的具体构造器的类，这可能会大大增加类的数量

## Prototype

### 概述

**原型模式**主要解决的问题就是创建大量重复对象，这些对象可能大部分属性一样，只有部分细节不同，而这部分对象内容本身比较复杂，生成过程可能从库或者RPC接口中获取数据的耗时较长，因此采用克隆的方式节省时间。

> 在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。

例如：获得一个需求时，直接写较耗时，因此在网上复制通用的代码，根据业务修改部分逻辑。

### 使用场景

- 类初始化比较耗时或需要消化非常多的资源
- 通过 new 产生一个对象需要非常繁琐的数据准备或访问权限
- 当要实例化的类是在运行时刻指定时，例如，通过动态装载

### 优点

- 自带的原型模式是基于内存二进制流的拷贝，比直接 new 一个对象性能高
- 使用克隆保存对象的状态，简化创建对象的过程

### 缺点

- 需要在每一个类中配置一个 clone 方法
- clone 方法位于类的内部，当需要修改时违背**开闭原则**
- 缺少构造函数的约束

## Singleton

**单例模式**确保一个类最多只有一个实例，并提供一个全局访问点。

### 使用场景

- 要求生成唯一序列号的环境；
- 在整个项目中需要一个共享访问点或共享数据
- 创建一个对象需要消耗的资源过多，如要访问IO和数据库等资源
- 需要定义大量的静态常量和静态方法（如工具类）的环境

### 优点

- 节约内存；
- 减少性能开销；
- 避免对资源的多重占用；
- 优化和共享资源访问。

### 缺点

- 一般无接口，扩展性差；
- 不易于测试；
- 和职责单一原则有冲突。
