# 工厂方法模式

## 业务背景

模拟互联网中在营销场景下的业务。用户根据中奖等级不同能够获得不同类型的奖品[1优惠券、2实物商品、3第三方兑换卡(爱奇艺)]，不同奖品的发送接口参数、返回值、发送逻辑都不同。

## demo1

不考虑任何扩展性，只为了尽快满足需求，所有业务都写在 `PrizeController` 里，包含奖品对象的创建以及不同奖品的分发逻辑，不同奖品之间只使用 `ifelse` 语句判断。从业务角度看，研发如期甚至提前实现了功能。

但重构麻烦，测试回归验证时间长，需要全部验证一次。后续增加新的奖品类型，需要修改业务层代码（PrizeController）会增加 `ifelse`，使得一个方法的长度会无限增加。

## demo2

使用了**简单工厂**。

将奖品抽象为一个公共接口 `IPrize`，内部提供发送奖品的 api，实际的奖品就是其不同的实现类，各自维护不同奖品的发送逻辑。

专门定义了一个工厂类 `PrizeFactory` 来负责创建所有的奖品，内部维护创建奖品的逻辑，根据传入的奖品类型创建不同的奖品，被创建的实例通常都具有共同的父类。

`PrizeController` 只需告诉工厂要创建哪种奖品，获取奖品对象后调用其发送的逻辑即可。

## demo3

通过**简单工厂+配置文件**的方式解除工厂对象和产品对象的耦合。

工厂类自动加载配置文件中的全类名，并创建对象进行存储，客户端如果需要对象，直接进行获取即可。

## demo4

使用了**工厂方法模式**，在**简单工厂**上进一步的加深。

提供一个创建奖品的工厂接口 `IPrizeFactory`，具体的实现工厂分别能创建不同的奖品，避免新增产品时需要修改工厂类代码，以及当唯一一个工厂类故障时，系统功能全部被影响。

