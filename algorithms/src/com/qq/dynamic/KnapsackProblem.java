package com.qq.dynamic;

/**
 * ==========动态规划算法介绍==========
 * 1) 动态规划(Dynamic Programming)算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解
 * 的处理算法
 * 2) 动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这
 * 些子问题的解得到原问题的解。
 * 3) 与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。 ( 即下一个子
 * 阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解 )
 * 4) 动态规划可以通过填表的方式来逐步推进，得到最优解.
 */
public class KnapsackProblem {
    /**
     * ==========动态规划算法最佳实践-背包问题==========
     * 1) 要求达到的目标为装入的背包的总价值最大，并且重量不超出
     * 2) 要求装入的物品不能重复
     * 思路分析和图解
     * 3) 背包问题主要是指一个给定容量的背包、若干具有一定价值和重量的物品，如何选择物品放入
     * 背包使物品的价值最大。其中又分 01 背包和完全背包(完全背包指的是：每种物品都有无限件可用)
     * 4) 这里的问题属于 01 背包，即每个物品最多放一个。而无限背包可以转化为 01 背包。
     * 5) 算法的主要思想，利用动态规划来解决。每次遍历到的第 i 个物品，根据 w[i]和 v[i]来确定
     * 是否需要将该物品放入背包中。即对于给定的 n 个物品，设 v[i]、w[i]分别为
     * 第 i 个物品的价值和重量，C 为背包的容量。再令 v[i][j]
     * 表示在前 i 个物品中能够装入容量为 j 的背包中的最大价值。
     * ==================则我们有下面的结果：=========================
     * (1) v[i][0]=v[0][j]=0; //表示 填入表 第一行和第一列是 0
     * (2) 当 w[i]> j 时：v[i][j]=v[i-1][j] // 当准备加入新增的商品的容量大于 当前背包的容量时，
     * 就直接使用上一个单元格的装入策略
     * (3) 当 j>=w[i]时： v[i][j]=max{v[i-1][j], v[i]+v[i-1][j-w[i]]}
     * // 当 准备加入的新增的商品的容量小于等于当前背包的容量, // 装入的方式:
     * v[i-1][j]： 就是上一个单元格的装入的最大值
     * v[i] : 表示当前商品的价值
     * v[i-1][j-w[i]] ： 装入 i-1 商品，到剩余空间 j-w[i]的最大值
     * 当 j>=w[i]时： v[i][j]=max{v[i-1][j], v[i]+v[i-1][j-w[i]]} :
     */
    public static void main(String[] args) {
        int[] w = {1, 4, 3};//物品的重量
        int[] val = {1500, 3000, 2000}; //物品的价值 这里 val[i] 就是前面讲的 v[i]
        int m = 4; //背包的容量
        knapsack(w, val, m);
    }

    /**
     * 动态规划-背包问题
     *
     * @param w   储存各个物品的重量
     * @param val 储存各个物品的价值
     * @param m   背包的容量
     */
    public static void knapsack(int[] w, int[] val, int m) {
//        // 创建二维数组，当前行及以上表示能放入的物品，当前列表示背包的容量
//        // v[i][j] 表示在前 i 个物品中能够装入容量为 j 的背包中的最大价值
//        int[][] v = new int[w.length + 1][m + 1];
//        //为了记录放入商品的情况，我们定一个二维数组
//        int[][] path = new int[w.length + 1][m+1];
//        //初始化第一行和第一列, 这里在本程序中，可以不去处理，因为默认就是 0
//        for(int i = 0; i < v.length; i++) {
//            v[i][0] = 0; //将第一列设置为 0
//        }
//        for(int i=0; i < v[0].length; i++) {
//            v[0][i] = 0; //将第一行设置 0
//        }
//        for(int i=1;i<v.length;i++){ // 依次遍历每一个商品
//            for (int j=1;j<v[0].length;j++){ // 依次遍历每一个背包容量
//                if(w[i-1]>j) { // 如果当前商品重量大于背包当前容量
//                    v[i][j] = v[i - 1][j]; // 当前最大价值与上一行这一列最大价值一样，相对于没有加新商品
//                }else {
//                    // 如果加上当前商品
//                    // 则最高价格应该是当前商品+上一行中剩余容量(当前背包容量-当前商品重量)的价值
//                    int value=val[i-1]+v[i-1][j-w[i-1]];
//                    if(value>v[i-1][j]){ // 如果加上当前商品的价格大于没加的价格
//                        path[i][j]=1; // 添加商品
//                        v[i][j]=value;
//                    }else // 否则当前最大价值与上一行这一列最大价值一样，相对于没有加新商品
//                        v[i][j] = v[i - 1][j];
//                }
//                System.out.print(v[i][j]+" ");
//            }
//            System.out.println();
//        }
//        int i=w.length;
//        int j=m;
//        System.out.println("背包能装下最大的价值为"+v[i][j]);
//        while (true){
//            if(i==0)
//                break;
//            if(path[i][j]==1){
//                System.out.println("放入一个"+i);
//                i--;
//                j=m-w[i];
//            }else
//                i--;
//        }
        /**
         * 优化版
         * 因为放入当前商品的最大dp[i][j]的值只与dp[i-1][0,...,j-1]有关
         * 所以只需定义一维数组即可，但要逆序遍历
         */
        int[] dp = new int[m + 1];
        for (int i = 0; i < val.length; i++) { // 遍历每一个商品
            for (int j = m; j >= w[i]; j--) { // 这里必须逆向遍历！！！背包容量一直到当前商品的重量
                if (j >= w[i]) // 只有当当前商品的重量能放进背包里才比较
                    dp[j] = Math.max(val[i] + dp[j - w[i]], dp[j]);
            }
        }
        for (int i : dp)
            System.out.println(i);
    }
}
